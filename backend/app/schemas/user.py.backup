# File: ./backend/app/schemas/user.py
# User-related Pydantic schemas for authentication and user management - FIXED for Pydantic V2

from typing import Optional, List
from pydantic import BaseModel, Field, EmailStr, field_validator, ConfigDict
from datetime import datetime
import re

from app.schemas.common import BaseSchema


class UserBase(BaseSchema):
    """Base user schema with common fields"""
    
    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
        from_attributes=True
    )
    
    email: EmailStr = Field(description="User's email address")
    first_name: Optional[str] = Field(
        default=None, 
        min_length=1, 
        max_length=50, 
        description="User's first name"
    )
    last_name: Optional[str] = Field(
        default=None, 
        min_length=1, 
        max_length=50, 
        description="User's last name"
    )


class UserRegister(UserBase):
    """Schema for user registration"""
    
    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True
    )
    
    password: str = Field(
        min_length=8, 
        max_length=100, 
        description="User's password (min 8 characters)"
    )
    confirm_password: str = Field(
        min_length=8, 
        max_length=100, 
        description="Password confirmation"
    )
    
    @field_validator('password')
    @classmethod
    def validate_password_strength(cls, v):
        """Validate password strength"""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        
        # Check for at least one uppercase letter
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        
        # Check for at least one lowercase letter
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        
        # Check for at least one digit
        if not re.search(r'\d', v):
            raise ValueError('Password must contain at least one digit')
        
        return v
    
    @field_validator('confirm_password')
    @classmethod
    def passwords_match(cls, v, info):
        """Validate that password and confirm_password match"""
        if 'password' in info.data and v != info.data['password']:
            raise ValueError('Passwords do not match')
        return v


class UserLogin(BaseModel):
    """Schema for user login"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    email: EmailStr = Field(description="User's email address")
    password: str = Field(min_length=1, description="User's password")


class UserUpdate(BaseModel):
    """Schema for user profile updates"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    first_name: Optional[str] = Field(
        default=None, 
        min_length=1, 
        max_length=50, 
        description="User's first name"
    )
    last_name: Optional[str] = Field(
        default=None, 
        min_length=1, 
        max_length=50, 
        description="User's last name"
    )


class UserPasswordChange(BaseModel):
    """Schema for password change"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    current_password: str = Field(min_length=1, description="Current password")
    new_password: str = Field(
        min_length=8, 
        max_length=100, 
        description="New password (min 8 characters)"
    )
    confirm_new_password: str = Field(
        min_length=8, 
        max_length=100, 
        description="New password confirmation"
    )
    
    @field_validator('new_password')
    @classmethod
    def validate_new_password_strength(cls, v):
        """Validate new password strength"""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        
        # Check for at least one uppercase letter
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        
        # Check for at least one lowercase letter
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        
        # Check for at least one digit
        if not re.search(r'\d', v):
            raise ValueError('Password must contain at least one digit')
        
        return v
    
    @field_validator('confirm_new_password')
    @classmethod
    def new_passwords_match(cls, v, info):
        """Validate that new_password and confirm_new_password match"""
        if 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('New passwords do not match')
        return v


class UserResponse(UserBase):
    """Schema for user data in API responses"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    id: int = Field(description="User's unique identifier")
    is_active: bool = Field(description="Whether the user account is active")
    is_verified: bool = Field(description="Whether the user email is verified")
    created_at: datetime = Field(description="Account creation timestamp")
    updated_at: Optional[datetime] = Field(default=None, description="Last update timestamp")


class UserSummary(BaseSchema):
    """Schema for user summary (minimal info)"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    id: int = Field(description="User's unique identifier")
    email: EmailStr = Field(description="User's email address")
    first_name: Optional[str] = Field(description="User's first name")
    last_name: Optional[str] = Field(description="User's last name")
    is_active: bool = Field(description="Whether the user account is active")
    
    @property
    def full_name(self) -> str:
        """Get user's full name"""
        parts = []
        if self.first_name:
            parts.append(self.first_name)
        if self.last_name:
            parts.append(self.last_name)
        return " ".join(parts) if parts else self.email


class UserWithStats(UserResponse):
    """Schema for user data with statistics"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    total_predictions: int = Field(default=0, description="Total number of predictions made")
    total_portfolios: int = Field(default=0, description="Total number of portfolio entries")
    last_prediction_date: Optional[datetime] = Field(
        default=None, 
        description="Date of last prediction"
    )
    last_login_date: Optional[datetime] = Field(
        default=None, 
        description="Date of last login"
    )


class Token(BaseModel):
    """Schema for JWT tokens"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    access_token: str = Field(description="JWT access token")
    token_type: str = Field(default="bearer", description="Token type")
    expires_in: int = Field(description="Token expiration time in seconds")


class TokenData(BaseModel):
    """Schema for token payload data"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    user_id: int = Field(description="User ID from token")
    email: str = Field(description="User email from token")
    exp: int = Field(description="Token expiration timestamp")


class UserPreferences(BaseModel):
    """Schema for user preferences and settings"""
    
    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True
    )
    
    email_notifications: bool = Field(default=True, description="Enable email notifications")
    push_notifications: bool = Field(default=True, description="Enable push notifications")
    default_currency: str = Field(default="USD", description="Default currency for display")
    timezone: str = Field(default="UTC", description="User's timezone")
    theme: str = Field(default="light", description="UI theme preference")
    
    @field_validator('default_currency')
    @classmethod
    def validate_currency(cls, v):
        """Validate currency code"""
        valid_currencies = ["USD", "EUR", "GBP", "JPY", "BTC", "ETH"]
        if v.upper() not in valid_currencies:
            raise ValueError(f'Currency must be one of: {", ".join(valid_currencies)}')
        return v.upper()
    
    @field_validator('theme')
    @classmethod
    def validate_theme(cls, v):
        """Validate theme option"""
        valid_themes = ["light", "dark", "auto"]
        if v.lower() not in valid_themes:
            raise ValueError(f'Theme must be one of: {", ".join(valid_themes)}')
        return v.lower()


class UserPasswordReset(BaseModel):
    """Schema for password reset request"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    email: EmailStr = Field(description="User's email address for password reset")


class UserPasswordResetConfirm(BaseModel):
    """Schema for password reset confirmation"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    token: str = Field(description="Password reset token")
    new_password: str = Field(
        min_length=8, 
        max_length=100, 
        description="New password (min 8 characters)"
    )
    confirm_password: str = Field(
        min_length=8, 
        max_length=100, 
        description="Password confirmation"
    )
    
    @field_validator('new_password')
    @classmethod
    def validate_password(cls, v):
        """Validate password strength"""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'\d', v):
            raise ValueError('Password must contain at least one digit')
        return v
    
    @field_validator('confirm_password')
    @classmethod
    def validate_password_match(cls, v, info):
        """Validate password confirmation"""
        if 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v


class UserProfile(UserResponse):
    """Extended user profile with preferences"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    last_login: Optional[datetime] = None
    timezone: Optional[str] = "UTC"
    language: Optional[str] = "en"
    currency: Optional[str] = "USD"


class UserStats(BaseModel):
    """User statistics schema"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    total_predictions: int = 0
    successful_predictions: int = 0
    accuracy_rate: float = 0.0
    favorite_cryptocurrencies: List[str] = []
    account_age_days: int = 0
    last_activity: Optional[datetime] = None


class UserListResponse(BaseModel):
    """User list response with pagination"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    users: List[UserResponse]
    total: int
    page: int
    per_page: int


# Token response schemas
class TokenResponse(BaseModel):
    """Token response schema"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int


class AuthResponse(BaseModel):
    """Authentication response schema"""
    
    model_config = ConfigDict(
        from_attributes=True,
        str_strip_whitespace=True
    )
    
    user: UserResponse
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int


class TokenRefresh(BaseModel):
    """Token refresh schema"""
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    refresh_token: str